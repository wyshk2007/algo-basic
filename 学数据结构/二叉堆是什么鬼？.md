二叉堆是一种应用很广的数据结构，今天，我们就来简单讲讲二叉堆。

#### 什么是二叉堆？

二叉堆是一种特殊的堆。具有如下的特性：

1. 具有完全二叉树的特性。
2. 堆中的任何一个父节点的值都大于等于它左右孩子节点的值，或者都小于等于它左右孩子节点的值。



根据第二条特性，我们又可以把二叉堆分成两类：

1、最大堆：父节点的值大于等于左右孩子节点的值。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d405af8cebd?w=610&h=413&f=png&s=15944)



2、最小堆：父节点的值小于等于左右孩子节点的值。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d23034eb1f6?w=553&h=378&f=png&s=15564)


我们把二叉堆的根节点称之为**堆顶**。根据二叉堆的特性，堆顶要嘛是整个堆中的**最大元素**，要嘛是**最小元素**。



今天，我们主要来讲讲二叉堆的三个主要操作：

1. 插入一个节点。
2. 删除一个节点。
3. 构建一个二叉堆。


不过这里需要注意的是，在二叉堆这种结构中，对于删除一个节点，我们一般删的是**根节点**。

下面我们以**最小堆**为例子，来讲讲这些操作。

#### 插入一个节点。

刚才我们说二叉堆具有完全二叉树的特性，因此，我们在插入一个节点的时候，应该先保证节点插入后，它仍然是一颗完全二叉树，然后再来进行调整，使它满足二叉堆的另一个特性。

所以，在插入的时候，我们把新节点插到完全二叉树的最后一个位置。例如：

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d23034eb1f6?w=553&h=378&f=png&s=15564)

插入0。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d4fba98ea7f?w=629&h=408&f=png&s=17486)


之后我们再来进行调整，调整的原则是：让新插入的节点与它的父节点进行比较，如果新节点小于父节点，则让新节点**上浮**，即和父节点交换位置。

上浮之后继续和它的父节点进行比较，直到父节点的值小于或等于该节点，才停止上浮，即插入结束。例如：

0比5小，上浮。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d5c6f96d4b6?w=610&h=413&f=png&s=18125)

0比2小于，上浮。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d622a073ddc?w=573&h=398&f=png&s=18187)



0比1小，上浮。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d6a6d7683b2?w=533&h=373&f=png&s=16877)

已经到达堆顶了，插入结束。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d6e83343e99?w=572&h=391&f=png&s=17089)

#### 删除节点。

前面说了，删除节点一般删除的是根节点。

和插入一样，由于二叉堆具有完全二叉树的特性，因为删除时候，首先我们是要马上恢复它具有完全二叉树的特性，所以我们是采取这样的策略：把根节点删除之后，用二叉堆的最后一个元素顶替上来，然后在进行调整恢复。例如：

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d852935e816?w=612&h=407&f=png&s=17352)


把0删除了之后，5替换上来。


![](https://user-gold-cdn.xitu.io/2018/9/26/16615d8d0e191c2a?w=580&h=377&f=png&s=15765)



之后再来调整，调整的规则和插入差不多类似，采取**下沉**的策略：让5和左右孩子节点相比较，如果左右节点有小于5的，则让那个较小的孩子代替5的位置，然后5下沉。

下沉之后，5继续和左右孩子相比，直到左右孩子都大于或等于5才结束。

如：5比1，3都大，1代替5的位置

![](https://user-gold-cdn.xitu.io/2018/9/26/16615d99786c5d6d?w=604&h=388&f=png&s=16768)


5比4，2都大，2代替5的位置。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615da171f85c7c?w=606&h=385&f=png&s=16763)


5已经不在具有左右孩子了，删除结束。


![](https://user-gold-cdn.xitu.io/2018/9/26/16615ddac5930396)

#### 构建二叉堆

所谓构建，就是给你一个有n个节点的**无序的完全二叉树**，然后把它构建成二叉堆。

刚才我们在删除一个节点的时候，把最后一个元素补到根元素的位置上去，然后再让这个元素依次**下沉**，实际上，在这个元素还没有下沉之前，它就可以看作是一颗**无序的完全二叉树了**。

也就是说，要把一个无序的完全二叉树调整为二叉堆，我们可以让**所有非叶子节点依次下沉**。不过下沉的顺序不是从根节点开始下沉(想一下相必你就 知道不能从根节点开始下沉)，而是从下面的非叶子节点下称，在依次往上。举个例子：

对于这样一颗无序的完全二叉树

![](https://user-gold-cdn.xitu.io/2018/9/26/16615dade5695512?w=656&h=430&f=png&s=16293)

8进行下沉。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615e1b6d3ab29a?w=578&h=390&f=png&s=16691)


接着，5进行下沉。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615e229006d4c5?w=609&h=418&f=png&s=17065)

2没问题，之后让7进行下沉

![](https://user-gold-cdn.xitu.io/2018/9/26/16615e229006d4c5?w=609&h=418&f=png&s=17065)

调整完成，构建结束。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615e2775ad96c2?w=585&h=432&f=png&s=16886)

#### 代码实现

不过这里需要说明的是，我们二叉树一般是采用**链表**的方式来实现的，但**二叉堆**我们是采用**数组**的方式来存储的。

![](https://user-gold-cdn.xitu.io/2018/9/26/16615e36c633803c?w=869&h=468&f=png&s=21058)

如果知道了一个节点的位置，如何知道一个节点的左右孩子节点的位置呢？

这其实不难，根据完全二叉树的特点，假如一个节点的下标为n,则可以求得它左孩子的下标为：2 * n+1；右孩子下标为：2 * n+2。



下面是构建代码的实现：

```java
public class BinaryHeap {
    //上浮操作，对插入的节点进行上浮

    /**
     *
     * @param arr
     * @param length ：表示二叉堆的长度
     */
    public static int[] upAdjust(int arr[], int length){
        //标记插入的节点
        int child = length - 1;
        //其父亲节点
        int parent = (child - 1)/2;
        //把插入的节点临时保存起来
        int temp = arr[child];

        //进行上浮
        while (child > 0 && temp < arr[parent]) {
            //其实不用进行每次都进行交换，单向赋值就可以了
            //当temp找到正确的位置之后，我们再把temp的值赋给这个节点
            arr[child] = arr[parent];
            child = parent;
            parent = (child - 1) / 2;
        }
        //退出循环代表找到正确的位置
        arr[child] = temp;
        return arr;
    }

    /**

     */


    /**
     *  下沉操作，执行删除操作相当于把最后
     *  * 一个元素赋给根元素之后，然后对根元素执行下沉操作
     * @param arr
     * @param parent 要下沉元素的下标
     * @param length 数组长度
     */
    public static int[] downAdjust(int[] arr, int parent, int length) {
        //临时保证要下沉的元素
        int temp = arr[parent];
        //定位左孩子节点位置
        int child = 2 * parent + 1;
        //开始下沉
        while (child < length) {
            //如果右孩子节点比左孩子小，则定位到右孩子
            if (child + 1 < length && arr[child] > arr[child + 1]) {
                child++;
            }
            //如果父节点比孩子节点小或等于，则下沉结束
            if (temp <= arr[child])
                break;
            //单向赋值
            arr[parent] = arr[child];
            parent = child;
            child = 2 * parent + 1;
        }
        arr[parent] = temp;
        return arr;
    }


    /**
     * 构建操作
     *
     * @param arr
     */
    public static int[] buildHead(int[] arr,int length) {
        //从最后一个非叶子节点开始下沉
        for (int i = (length - 2) / 2; i >= 0; i--) {
            arr = downAdjust(arr, i, length);
        }
        return arr;
    }
}

```

本次讲解到此结束。下篇继续讲解和堆有关的知识点。至于bitmap算法优化的那篇，会在之后给出。

学习更多**算法** + **计算机基础知识**，欢迎关注我的微信公众号，每天准时推送技术干货

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200306223728524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTA3Nzk3,size_16,color_FFFFFF,t_70)







